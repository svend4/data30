# Схема сущностей и отношений

## 1. Поля сущностей

Ниже приведён базовый набор полей для всех доменных сущностей (например, `Module`, `Function`, `UseCase`, `Macro`, `Review`, `Rating` и т.п.).

| Поле | Тип | Обязательное | Описание |
|---|---|---|---|
| `id` | UUID (v4) | да | Уникальный идентификатор сущности. |
| `name` | String (1–255) | да | Человекочитаемое имя. Должно быть уникально в рамках типа сущности. |
| `description` | Text | нет | Подробное описание. |
| `metadata` | JSONB / Map<String, Any> | нет | Дополнительные атрибуты, не влияющие на логику (теги, ссылки, авторы и т.п.). |
| `created_at` | Timestamp (UTC) | да | Время создания записи. |
| `updated_at` | Timestamp (UTC) | да | Время последнего изменения записи. |

Дополнительно для всех версионируемых сущностей:

| Поле | Тип | Обязательное | Описание |
|---|---|---|---|
| `version` | SemVer String | да | Версия в формате `MAJOR.MINOR.PATCH`. |
| `revision` | Integer | да | Последовательная ревизия для истории изменений. |
| `effective_at` | Timestamp (UTC) | да | Дата/время вступления версии в силу. |
| `status` | Enum | да | Состояние (`draft`, `active`, `deprecated`). |

### 1.1. Доменные сущности и их специфические поля

**`Function`**
- `signature` (String, optional) — публичная сигнатура/контракт.
- `module_ids` (UUID[]) — ссылки на модули, где используется функция.

**`Module`**
- `owner` (String, optional) — ответственная команда/роль.
- `function_ids` (UUID[]) — список функций, входящих в модуль.

**`UseCase`**
- `module_ids` (UUID[]) — модули, участвующие в сценарии.
- `function_ids` (UUID[]) — функции, которые выполняют сценарий.

**`Macro`**
- `use_case_ids` (UUID[]) — сценарии, которые объединяет макрос.

**`Review`**
- `target_type` (Enum: `function`, `module`, `use_case`, `macro`) — тип сущности, которую оценивают.
- `target_id` (UUID) — идентификатор целевой сущности.
- `author` (String, optional) — автор/роль ревью.
- `rating_id` (UUID) — ссылка на сущность `Rating`.
- `comment` (Text, optional) — текст отзыва.

**`Rating`**
- `score` (Integer) — оценка, например 1–5.
- `scale` (String, optional) — описание шкалы (например, `1-5`).
- `label` (String, optional) — человекочитаемая метка оценки (например, `good`).

## 2. Связи между сущностями

### Примеры ключевых связей

- **`Function` ↔ `Module`**
  - Тип: многие-ко-многим (M:N)
  - Интерпретация: функция может принадлежать нескольким модулям, модуль содержит множество функций.
  - Реализация: таблица/ребро `module_function`.

- **`UseCase` ↔ `Macro`**
  - Тип: многие-ко-многим (M:N)
  - Интерпретация: use case может быть реализован несколькими macro, и macro может участвовать в нескольких use case.
  - Реализация: таблица/ребро `usecase_macro`.

- **`Review` → `Rating`**
  - Тип: один-ко-одному (1:1)
  - Интерпретация: отзыв использует ровно одну оценку.
  - Реализация: внешний ключ `rating_id` в `reviews`.

- **`Review` → (`Function`/`Module`/`UseCase`/`Macro`)**
  - Тип: многие-к-одному (M:1) через `target_type` + `target_id`.
  - Интерпретация: отзыв относится к одной целевой сущности.
  - Реализация: полиморфная связь либо отдельные таблицы связей.

### Дополнительные типовые связи (опционально)

- **`Module` ↔ `Component`**: один-ко-многим (1:N)
- **`Service` ↔ `UseCase`**: один-ко-многим (1:N)
- **`Function` ↔ `Function`**: многие-ко-многим (M:N) для зависимостей/вызовов

## 3. Ограничения

### Обязательность (NOT NULL)
- `id`, `name`, `created_at`, `updated_at` — обязательны для всех сущностей.

### Уникальность
- `id` — глобально уникален.
- `name` — уникален **в пределах типа сущности** (например, два разных `Module` не могут иметь одинаковый `name`).
- Для связей M:N рекомендуется уникальный составной ключ (например, `(module_id, function_id)`), чтобы исключить дубликаты связей.

### Типы и валидация
- `id`: UUID v4.
- `name`: строка 1–255 символов, запрещены пустые строки.
- `description`: свободный текст.
- `metadata`: JSON-объект, допустимы только сериализуемые значения.
- `created_at`, `updated_at`: UTC timestamps.

### Каскадные правила
- Удаление сущности должно удалять связи (CASCADE) либо блокироваться (RESTRICT) в зависимости от критичности данных.

## 4. Согласование со схемой хранения

### Выбранная модель: **гибридная (табличная + графовая)**

- **Табличная часть** хранит сущности и их поля (`id`, `name`, `description`, `metadata`, `created_at`, `updated_at`).
- **Графовая часть** хранит связи между сущностями (ребра M:N, зависимостей и т.п.).

#### Почему гибрид:
- Табличная модель удобна для CRUD и строгих ограничений.
- Графовая модель упрощает обход отношений (например, цепочки зависимостей `Function → Function` или связь `UseCase → Macro → Function`).

### Соответствие

- **Entities** → таблицы (например, `modules`, `functions`, `use_cases`, `macros`).
- **Relations** → отдельные таблицы связей (в RDBMS) **или** ребра (в графовой БД).
- `metadata` хранится в JSONB (PostgreSQL) или аналогичном типе в выбранной СУБД.

Если проект полностью табличный, связи M:N реализуются через join-таблицы; если полностью графовый — сущности становятся вершинами, а таблицы заменяются ребрами, ограничения реализуются на уровне приложений/валидации.
